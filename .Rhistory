lists <- lists %>%
pivot_wider(
names_from = Question,
values_from = Value
)
# Rename lists col headers
colnames(lists) <- c('UnitName','TotalLists','NonGILists','BCSPLists','StandardGILists','ERCP_EUSLists','OtherGILists')
# Unpivot for chart
lists_chart_data <- subset(lists, select = -2)
lists_chart_data <- lists_chart_data %>%
pivot_longer(
cols = !UnitName,
names_to = "ListType",
values_to = "Value"
)
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(stat = "identity", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
########################################
# Create check to see whether sum of columns = total
lists <- lists %>%
mutate(TotalCheck = select(., -c(1:2)) %>%
rowSums(na.rm = TRUE)
)
lists <- lists %>%
ifelse(TotalLists != TotalCheck,
TotalCheck1 = "error",
TotalCheck1 = "")
#| echo: false
library(dplyr)
library(kableExtra)
# Call subscript
source("C:/Users/martin.bloyce/OneDrive - NHS England/Documents/diagnostics_endoscopy/endoscopy_lists.R")
# Import libraries
library(dplyr)
library(ggplot2)
library(NHSRtheme)
library(readxl)
library(tidyverse)
# Import data
endoscopy_stocktake <- read_excel("C:/Users/martin.bloyce/OneDrive - NHS England/Restricted Library/SE/Analysis/Diagnostics/Endoscopy Stocktake/Endoscopy Stocktake Database with pivot table.xlsx",
sheet = "Backing Data", skip = 2)
# Rename column headers
colnames(endoscopy_stocktake) <- c('ICB', 'Trust', 'Directorate', 'UnitName', 'QuestionKey','Question', 'Value', 'ValueType', 'SetResponseAnswer', 'FreeText', 'blank1', 'blank2', 'blank3')
# Set value to numeric
endoscopy_stocktake$Value <- as.numeric(endoscopy_stocktake$Value)
# Subset to 'lists' questions
lists_questions <- c('27','28','29','30','31','32')
lists <- subset(endoscopy_stocktake,
endoscopy_stocktake$QuestionKey %in% lists_questions,
select = c('UnitName', 'Question', 'Value')
)
lists <- lists %>% distinct()  # Remove duplicated rows
# Create pivot table for lists
lists <- lists %>%
pivot_wider(
names_from = Question,
values_from = Value
)
# Rename lists col headers
colnames(lists) <- c('UnitName','TotalLists','NonGILists','BCSPLists','StandardGILists','ERCP_EUSLists','OtherGILists')
# Unpivot for chart
lists_chart_data <- subset(lists, select = -2)
lists_chart_data <- lists_chart_data %>%
pivot_longer(
cols = !UnitName,
names_to = "ListType",
values_to = "Value"
)
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(stat = "identity", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
# Import libraries
library(dplyr)
library(ggplot2)
library(NHSRtheme)
library(readxl)
library(tidyverse)
# Import data
endoscopy_stocktake <- read_excel("C:/Users/martin.bloyce/OneDrive - NHS England/Restricted Library/SE/Analysis/Diagnostics/Endoscopy Stocktake/Endoscopy Stocktake Database with pivot table.xlsx",
sheet = "Backing Data", skip = 2)
# Rename column headers
colnames(endoscopy_stocktake) <- c('ICB', 'Trust', 'Directorate', 'UnitName', 'QuestionKey','Question', 'Value', 'ValueType', 'SetResponseAnswer', 'FreeText', 'blank1', 'blank2', 'blank3')
# Set value to numeric
endoscopy_stocktake$Value <- as.numeric(endoscopy_stocktake$Value)
# Subset to 'lists' questions
lists_questions <- c('27','28','29','30','31','32')
lists <- subset(endoscopy_stocktake,
endoscopy_stocktake$QuestionKey %in% lists_questions,
select = c('UnitName', 'Question', 'Value')
)
lists <- lists %>% distinct()  # Remove duplicated rows
# Create pivot table for lists
lists <- lists %>%
pivot_wider(
names_from = Question,
values_from = Value
)
# Rename lists col headers
colnames(lists) <- c('UnitName','TotalLists','NonGILists','BCSPLists','StandardGILists','ERCP_EUSLists','OtherGILists')
# Unpivot for chart
lists_chart_data <- subset(lists, select = -2)
lists_chart_data <- lists_chart_data %>%
pivot_longer(
cols = !UnitName,
names_to = "ListType",
values_to = "Value"
)
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(stat = "identity", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
########################################
# Create check to see whether sum of columns = total
#lists <- lists %>%
#  mutate(TotalCheck = select(., -c(1:2)) %>%
#           rowSums(na.rm = TRUE)
#  )
#lists <- lists %>%
#  ifelse(TotalLists != TotalCheck,
#         TotalCheck1 = "error",
#         TotalCheck1 = "")
#| echo: false
library(dplyr)
library(kableExtra)
# Call subscript
source("C:/Users/martin.bloyce/OneDrive - NHS England/Documents/diagnostics_endoscopy/endoscopy_lists.R")
#| echo: false
library(dplyr)
library(kableExtra)
# Call subscript
source("C:/Users/martin.bloyce/OneDrive - NHS England/Documents/diagnostics_endoscopy/endoscopy_lists.R")
#| echo: false
library(dplyr)
library(kableExtra)
# Call subscript
source("C:/Users/martin.bloyce/OneDrive - NHS England/Documents/diagnostics_endoscopy_stocktake/endoscopy_fit.R")
#| echo: false
library(dplyr)
library(kableExtra)
# Call subscript
source("C:/Users/martin.bloyce/OneDrive - NHS England/Documents/GitHub/diagnostics_endoscopy_stocktake/endoscopy_fit.R")
# Create table visual output
kable(fit_table,
col.names = colnames(fit_table),
caption = "Sample Table") %>%
kable_styling(full_width = FALSE) %>%
add_header_above(c(" ", "Percentage of colonoscopies with a FIT10+ result" = 8)) %>%
row_spec(0, bold = TRUE, color = "white", background = "gray") %>%
column_spec(9, color = "white",
background = spec_color(fit_table$percentageFit10[1:12], begin = 0.9, end = 0.4, option = 'H'))
# Visualise charts
a
b
# Import libraries
library(dplyr)
library(ggplot2)
library(NHSRtheme)
library(readxl)
library(tidyverse)
# Import data
endoscopy_stocktake <- read_excel("C:/Users/martin.bloyce/OneDrive - NHS England/Restricted Library/SE/Analysis/Diagnostics/Endoscopy Stocktake/Endoscopy Stocktake Database with pivot table.xlsx",
sheet = "Backing Data", skip = 2)
# Rename column headers
colnames(endoscopy_stocktake) <- c('ICB', 'Trust', 'Directorate', 'UnitName', 'QuestionKey','Question', 'Value', 'ValueType', 'SetResponseAnswer', 'FreeText', 'blank1', 'blank2', 'blank3')
# Set value to numeric
endoscopy_stocktake$Value <- as.numeric(endoscopy_stocktake$Value)
# Subset to 'lists' questions
lists_questions <- c('27','28','29','30','31','32')
lists <- subset(endoscopy_stocktake,
endoscopy_stocktake$QuestionKey %in% lists_questions,
select = c('UnitName', 'Question', 'Value')
)
lists <- lists %>% distinct()  # Remove duplicated rows
# Create pivot table for lists
lists <- lists %>%
pivot_wider(
names_from = Question,
values_from = Value
)
# Rename lists col headers
colnames(lists) <- c('UnitName','TotalLists','NonGILists','BCSPLists','StandardGILists','ERCP_EUSLists','OtherGILists')
# Unpivot for chart
lists_chart_data <- subset(lists, select = -2)
lists_chart_data <- lists_chart_data %>%
pivot_longer(
cols = !UnitName,
names_to = "ListType",
values_to = "Value"
)
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(position = "fill", stat = "identity", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, fill=ListType)) +
geom_bar(position = "fill", stat = "identity", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, fill=factor(ListType))) +
geom_bar(position = "fill", stat = "identity", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(position = "fill", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(stat = "identity", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(position = "fill", stat = "identity", show.legend = TRUE) +
geom_text(data=subset(lists_chart_data, Value != 0), aes(label = Value), size = 3, position = position_stack(vjust = 0.5)) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(position = "fill", stat = "identity", show.legend = TRUE) +
theme(axis.text.x = element_text(angle = 90)) +
scale_fill_nhs() +
coord_flip()
lists_chart
lists_chart <- lists_chart_data %>%
ggplot(., aes(x=UnitName, y=Value, fill=ListType)) +
geom_bar(position = "fill", stat = "identity", show.legend = TRUE) +
theme(axis.text.x = element_text(angle = 90)) +
scale_y_continuous(labels = scales::percent) +
scale_fill_nhs() +
coord_flip()
lists_chart
View(lists)
rm(list = setdiff(ls(), c("lists_chart", "lists")))
View(lists)
# install.packages("remotes")
remotes::install_github("nhs-r-community/NHSRpopulation")
library(NHSRpopulation)
test_check("NHSRpopulation")
library(testthat)
library(NHSRpopulation)
test_check("NHSRpopulation")
#' Getting data from the IMD api
#'
#' @description
#' Only required for IMD as postcodes is routed through the {NHSRpostcodetools}
#' package
#'
#' @return dataset
#' @export
api_url <- function() {
httr2::request(paste0(
"https://services3.arcgis.com/ivmBBrHfQfDnDf8Q/arcgis/rest/services/",
"Indices_of_Multiple_Deprivation_(IMD)_2019/FeatureServer/0/query"
)) |>
httr2::req_url_query(f = "json")
}
#' use batched IDs to retrieve table data
#'
#' @param req used in function \code{\link{imd_api}}
#' @param ids_vec used in function \code{\link{imd_api}}
#'
#' @return function
#' @noRd
retrieve_data <- function(req, ids_vec) {
ids <- stringr::str_flatten(ids_vec, collapse = ",")
req |>
httr2::req_url_query(objectIds = ids) |>
httr2::req_url_query(outFields = "*") |> # returns all columns
httr2::req_url_query(returnGeometry = FALSE) |> # superfluous tbf
httr2::req_retry(max_tries = 3) |> # shouldn't be needed
httr2::req_perform()
}
#' pull actual data out from API JSON response
#'
#' @param respused in function \code{\link{imd_api}}
#'
#' @return function
#' @noRd
pull_table_data <- function(resp) {
resp |>
httr2::resp_check_status() |>
httr2::resp_body_json() |>
purrr::pluck("features") |>
purrr::map_df("attributes") |>
janitor::clean_names()
}
#' Get IMD data through API
#'
#' @description
#' Relies on functions \code{\link{retrieve_data}},
#' \code{\link{pull_table_data}} and \code{\link{api_url}}
#'
#' @param text String. Used in the query function and feeds in either postcodes
#' or lsoas from data in the expected API url format
#' @param req
#'
#' @return data frame
#' @noRd
imd_api <- function(text, req) {
ids <- req |>
httr2::req_url_query(returnIdsonly = TRUE) |>
httr2::req_url_query(where = text) |>
httr2::req_perform() |>
httr2::resp_body_json() |>
purrr::pluck("objectIds")
ids_batched <- NHSRpostcodetools::batch_it(ids, 100L)
# Uses function retrieve data
# safely handle any errors
poss_retrieve_data <- purrr::possibly(retrieve_data)
resps <- ids_batched |>
purrr::map(\(x) poss_retrieve_data(req, x)) |>
purrr::compact()
# Uses function pull_table_data
poss_pull_table_data <- purrr::possibly(pull_table_data)
data_out <- resps |>
purrr::map(poss_pull_table_data) |>
purrr::list_rbind()
data_out
}
View(imd_api)
#' Query information to restrict data returned
#'
#' @description
#' This function queries the API based on the information required and returns
#' ids as these have no restriction applied to them.
#' The IMD API restricts to 2k records for example.
#'
#' Postcode and LSOA parameters require data because bringing all the data
#' from the Online_ONS_Postcode_Directory_Live will take too long and is often
#' unnecessary.
#'
#' @param url_type String defaults to `postcode` which returns information from
#' Online_ONS_Postcode_Directory_Live to return Postcode information via the
#' {NHSRpostcodetools} package. `imd` connects to
#' Indices_of_Multiple_Deprivation_(IMD)_2019 to return IMD information.
#' @param data dataframe or vector.The data that will connect to either the
#' postcode API or imd API.
#' @param fix_invalid Boolean, default `TRUE`. Whether to try to fix any
#'  postcodes that are not found (potentially because they are terminated codes,
#'  or contain typos).
#' @param column String. Default would mean the automatic connection of a
#' column called `postcode` if postcode data is being expected or `lsoa11` if
#' imd data as requested via the parameter `url_type = "imd"`.
#'
#' @return data frame
#' @export
#'
get_data <- function(data,
url_type = c(
"postcode",
"imd"
),
fix_invalid = TRUE,
column = "default") {
url_type <- match.arg(url_type)
req <- api_url()
column <- rlang::as_string(column)
value <- NULL
lsoa11cd <- NULL
lsoa_code <- NULL
imd_decile <- NULL
imd_rank <- NULL
imd_score <- NULL
# Check there is corresponding type data somewhere in data frame
# Use this to allow for other column names to be used in later code
is_postcode_check <- sum(is_postcode(as.vector(t(data))), na.rm = TRUE)
is_lsoa_check <- sum(is_lsoa(as.vector(t(data))), na.rm = TRUE)
if ("postcode" %in% colnames(data)) {
column <- "postcode"
} else if ("lsoa11" %in% colnames(data)) {
column <- "lsoa11"
} else {
column <- rlang::eval_tidy(rlang::quo(column))
}
# Check the data frame or vector for any postcode to then run through
# the postcode_data_join API
if (is.data.frame(data) && is_postcode_check > 0) {
data_transformed <- NHSRpostcodetools::postcode_data_join(
x = data[[column]],
fix_invalid = fix_invalid,
var = column
)
} else if (is.character(data) && is_postcode_check > 0) {
data_transformed <- NHSRpostcodetools::postcode_data_join(
x = data,
fix_invalid = fix_invalid,
var = column # Not required but doesn't cause error
)
}
## Generate specific text for the url
if (is.character(data) && is_postcode_check == 0 &&
is_lsoa_check > 0) {
text <- paste0(
"LSOA11CD IN ('",
paste(data,
collapse = "', '"
), "')"
)
} else if (is.data.frame(data) && is_postcode_check == 0 &&
is_lsoa_check > 0) {
text <- paste0(
"LSOA11CD IN ('",
paste(data[[column]],
collapse = "', '"
), "')"
)
} else if (exists("data_transformed") && url_type == "imd") {
text <- paste0(
"LSOA11CD IN ('",
paste(data_transformed$lsoa_code,
collapse = "', '"
), "')"
)
}
# Because APIs only return data where a match has been made which results in
# non matched data being dropped this joins back to the original.
# Postcode information is passed through {NHSRpostcodetools} which handles
# this but IMD is handled here.
if (exists("data_transformed") && is.data.frame(data)) {
pc_data <- data |>
dplyr::left_join(
data_transformed
)
} else if (exists("data_transformed") && is.character(data)) {
pc_data <- data_transformed
}
## IMD data
if (is_postcode_check == 0 && is_lsoa_check > 0 &&
is.data.frame(data)) {
data_out <- imd_api(
text = text,
req = req
)
imd_data <- data |>
dplyr::left_join(
data_out,
dplyr::join_by({{ column }} == lsoa11cd)
)
} else if (is_postcode_check == 0 && is_lsoa_check > 0 && is.character(data)) {
data_out <- imd_api(
text = text,
req = req
)
imd_data <- tibble::as_tibble(data) |>
dplyr::left_join(
data_out,
dplyr::join_by(value == lsoa11cd)
) |>
dplyr::rename(lsoa11 = value)
}
## Final data
if (exists("pc_data") && url_type == "imd") {
data_out <- imd_api(
text = text,
req = req
)
pc_data |>
dplyr::left_join(
data_out,
dplyr::join_by(lsoa_code == lsoa11cd)
) |>
dplyr::select(
1:3,
imd_decile,
imd_rank,
imd_score,
dplyr::everything()
)
} else if (exists("pc_data") && url_type == "postcode") {
pc_data
} else {
imd_data
}
}
View(get_data)
View(api_url)
